/*
See LICENSE folder for this sampleâ€™s licensing information.

Abstract:
Metal shaders used for this sample
*/

#include <metal_stdlib>

using namespace metal;

// Include header shared between this Metal shader code and C code executing Metal API commands
#include "AAPLShaderTypes.h"

// Per-vertex inputs fed by vertex buffer laid out with MTLVertexDescriptor in Metal API
struct Vertex
{
    float3 position [[attribute(AAPLVertexAttributePosition)]];
    float2 texCoord [[attribute(AAPLVertexAttributeTexcoord)]];
    half3 normal    [[attribute(AAPLVertexAttributeNormal)]];
    half3 tangent   [[attribute(AAPLVertexAttributeTangent)]];
    half3 bitangent [[attribute(AAPLVertexAttributeBitangent)]];
};

// Vertex shader outputs and per-fragment inputs.  Includes clip-space position and vertex outputs
//  interpolated by rasterizer and fed to each fragment generated by clip-space primitives.
struct ColorInOut
{
    float4 position [[position]];
    float2 texCoord;

    half3  worldPos;
    half3  tangent;
    half3  bitangent;
    half3  normal;
};

vertex ColorInOut vertexTransform(Vertex in [[stage_in]],
                                  constant AAPLUniforms & uniforms [[ buffer(AAPLBufferIndexUniforms) ]])
{
    ColorInOut out;

    out.position = uniforms.modelViewProjectionMatrix * float4(in.position, 1.0);

    out.texCoord = in.texCoord;

    half3x3 normalMatrix = half3x3(uniforms.normalMatrix);
    out.tangent   = normalMatrix * in.tangent;
    out.bitangent = normalMatrix * in.bitangent;
    out.normal    = normalMatrix * in.normal;
    out.worldPos = (half3) (uniforms.modelMatrix * float4(in.position, 1.0)).xyz;

    return out;
}

fragment float4 fragmentLighting(ColorInOut in [[stage_in]],
                                 constant AAPLUniforms & uniforms [[ buffer(AAPLBufferIndexUniforms) ]],
                                 texture2d<half> baseColorMap [[ texture(AAPLTextureIndexBaseColor) ]],
                                 texture2d<half> normalMap    [[ texture(AAPLTextureIndexNormal) ]],
                                 texture2d<half> specularMap  [[ texture(AAPLTextureIndexSpecular) ]])
{
    constexpr sampler linearSampler (mip_filter::linear,
                                     mag_filter::linear,
                                     min_filter::linear);

    const half4 baseColorSample = baseColorMap.sample (linearSampler, in.texCoord.xy);
    half3 normalSampleRaw = normalMap.sample (linearSampler, in.texCoord.xy).xyz;

    normalSampleRaw.xy = normalSampleRaw.xy * 2.0 - 1.0;
    const half3 normalSample    = normalize(normalSampleRaw);
    const half  specularSample  = specularMap.sample  (linearSampler, in.texCoord.xy).x;

    in.tangent   = normalize (in.tangent);
    in.bitangent = normalize (in.bitangent);
    in.normal    = normalize (in.normal);

    half3x3 tangentMatrix = half3x3(in.tangent, in.bitangent, in.normal);

    float3 normal = (float3) (tangentMatrix * normalSample);

    float3 directionalContribution = float3(0);
    float3 specularTerm = float3(0);
    {
        float nDotL = saturate(dot(normal, uniforms.directionalLightInvDirection));

        float3 diffuseTerm = uniforms.directionalLightColor * nDotL;

        float3 eyeDir = normalize (uniforms.cameraPos - float3(in.worldPos));

        float3 halfwayVector = normalize(uniforms.directionalLightInvDirection + eyeDir);

        float reflectionAmount = saturate(dot(normal, halfwayVector));

        float specularIntensity = saturate(powr(reflectionAmount, uniforms.materialShininess));

        specularTerm = uniforms.directionalLightColor * specularIntensity * float(specularSample);

        float3 baseColor = float3(baseColorSample.xyz);
        directionalContribution = baseColor * (diffuseTerm + uniforms.ambientLightColor);
    }

    float3 color = specularTerm + directionalContribution;

    return float4(color, baseColorSample.w);
}
